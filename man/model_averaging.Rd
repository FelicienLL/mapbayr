% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modelaveraging.R
\name{model_averaging}
\alias{model_averaging}
\alias{compute_weights}
\alias{do_model_averaging}
\title{Average predictions from multiple models}
\usage{
model_averaging(
  ...,
  output_function = as.data.frame,
  scheme = c("LL", "AIC"),
  estlist = NULL
)

compute_weights(..., scheme = c("LL", "AIC"), estlist = NULL)

do_model_averaging(list_of_tabs, weights_matrix)
}
\arguments{
\item{...}{estimation objects generated from \code{\link[=mapbayest]{mapbayest()}} to compute weight from}

\item{output_function}{a unique function that take any estimation object and return a table with controled variables, dimensions and attributes.}

\item{scheme}{scheme weight, either "LL" or "AIC"}

\item{estlist}{a list of estimation objects. Overrides \code{...}}

\item{list_of_tabs, weights_matrix}{respectively outputs of the \code{output_function} and \code{\link[=compute_weights]{compute_weights()}}}
}
\value{
\itemize{
\item \code{\link[=model_averaging]{model_averaging()}} and \code{\link[=do_model_averaging]{do_model_averaging()}}: a data.frame of the same dimensions and attributes as the outputs
\item \code{\link[=compute_weights]{compute_weights()}}: a matrix with IDs as rows and estimations as columns
}
}
\description{
Model Averaging consists in analyzing the same data with different models
and to average their predictions.
In order to perform weigthed means of clearance predictions, (or
concentrations, or any metric of interest), it is necessary to compute
the "weight" of each estimation.
It is informed by the likelihood of estimation.
Two weighting scheme are currently implemented, one based on the log-
likelihood ("LL", the default), the other on the Akaike criterion ("AIC").
The method was previously described by Uster et al
\href{https://ascpt.onlinelibrary.wiley.com/doi/full/10.1002/cpt.2065}{(Clinical Pharmacology and Therapeutics, 2021)}.
}
\examples{
library(magrittr)
same_data_and_est <- function(x){
  x \%>\%
    adm_rows(ID = 2, time = 0, amt = 100, addl = 3, ii = 24) \%>\%
    obs_rows(ID = 2, time = 96, DV = 1) \%>\%
    adm_rows(ID = 9, time = 0, amt = 200, addl = 3, ii = 24) \%>\%
    obs_rows(ID = 9, time = 96, DV = 2) \%>\%
    mapbayest()
  }

create_output <- function(x){
  x <- as.data.frame(x)
  x[x$mdv == 0,c("ID", "time", "DV", "IPRED")]
  }

mod <- exmodel(1, add_exdata = FALSE)

est1 <- mod \%>\%
  mrgsolve::param(TVCL = 2) \%>\%
  same_data_and_est()

est2 <- mod \%>\%
  mrgsolve::param(TVCL = 10) \%>\%
  same_data_and_est()

model_averaging(
  est1,
  est2,
  output_function = create_output
  )

W <- compute_weights(CL2 = est1, CL10 = est2)
compute_weights(estlist = list(A = est1, B = est2, est1))

do_model_averaging(
  list_of_tabs = list(create_output(est1), create_output(est2)),
  weights_matrix = W
  )

}
